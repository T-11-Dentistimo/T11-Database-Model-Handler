const dentist = require("../models/dentist");
const { booking } = require("../models/booking");

/**
 * This method will double check if there are free time slots for the incoming booking's time & date at the dentist clinic
 * @param incomingBooking The booking which to check the availability for
 * @returns hasAvailableSlot: True if there are available slots and false otherwise
 */
async function checkIfAvailableTimeSlots(incomingBooking) {
  let numberOfSlots = 0;
  let numberOfBookings = 0;
  let hasAvailableSlot = false;

  // The dentists have 2 ids, one (id) is the one given to us in the requirement document (kept in case the examiners would have
  // to run automatic tests) and the other (_id) is the id automatically generated by mongo.
  const foundDentist = await dentist.findOne({ id: incomingBooking.dentistid });
  numberOfSlots = foundDentist.dentists;

  const bookings = await booking.find({
    dentistid: foundDentist._id,
    date: incomingBooking.date,
    time: incomingBooking.time,
  });

  // Set the dentist id to the the actual mongo db id so that the booking can be saved
  incomingBooking.dentistid = foundDentist._id;

  numberOfBookings = bookings.length;
  console.log(numberOfBookings);
  if (numberOfBookings < numberOfSlots) {
    hasAvailableSlot = true;
  }
  return hasAvailableSlot;
}

/**
 * This method will make sure that the time intervall is saved in the database as e.g '7.30-7.00', and not, for example, as '07.00-07.30'
 * @param incomingBooking The booking of which the time should be formatted
 * @returns {incomingBooking.time} In a possibly new format depending on in what format it was received
 */
async function formatTimeIntervall(incomingBooking) {
  if (incomingBooking.time.substring(0, 1) === "0") {
    incomingBooking.time = incomingBooking.time.slice(1);
    if (incomingBooking.time.substring(5, 6) === "0") {
      incomingBooking.time =
        incomingBooking.time.substring(0, 5) +
        incomingBooking.time.substring(6);
    }
  }
  return incomingBooking.time;
}

/**
 * This method will make sure that the incoming booking's date is later than the
 * the current date, to prevent users from booking appointments in the past
 * @param {Object} incomingBooking The booking of which the date need to be validated
 * @returns True or false
 */
async function validateThatDateIsInFuture(incomingBooking) {
  let incomingDate = new Date(incomingBooking.date);
  let currentDate = new Date();

  if (incomingDate.getFullYear() > currentDate.getFullYear()) {
    return true;
  }
  if (incomingDate.getFullYear() < currentDate.getFullYear()) {
    return false;
  }
  if (
    incomingDate.getMonth() == currentDate.getMonth() &&
    incomingDate.getDate() > currentDate.getDate()
  ) {
    return true;
  } else {
    console.log("EALRIER DATE BUT SAME MONTH");
    return false;
  }
}

/**
 * This method creates a confirmation with the info about the booking that the user has made.
 * It also cuts the timestamp from the date since it is unnecessary
 * @param {Object} booking The booking that the confirmation pertains to
 * @param {String} sessionId The session ID of the user that made the booking
 * @param {Number} clinicId The one digit Number ID of the dental clinic where the booking was made
 */
async function createConfirmation(booking, sessionId, clinicId) {
  let date = booking.date.toISOString();
  date = date.substring(0, 10);
  console.log(date);
  return {
    userid: booking.userid,
    date: date,
    time: booking.time,
    name: booking.name,
    sessionId: sessionId,
    dentistId: clinicId,
  };
}

module.exports = {
  checkIfAvailableTimeSlots,
  formatTimeIntervall,
  createConfirmation,
  validateThatDateIsInFuture,
};
